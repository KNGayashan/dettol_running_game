<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Subway Surfers Runner</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Arial', sans-serif;
      overflow: hidden;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }

    #gameCanvas {
      display: block;
      width: 100%;
      height: 100vh;
    }

    /* UI Overlay */
    #ui {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1000;
    }

    #score-panel {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px 25px;
      border-radius: 10px;
      color: white;
      font-size: 20px;
      font-weight: bold;
    }

    #score-panel div {
      margin: 5px 0;
    }

    #coin-count {
      color: #ffd700;
    }

    #distance {
      color: #00ff88;
    }

    /* Heat Bar */
    #heat-bar-container {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 300px;
      height: 30px;
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid white;
      border-radius: 15px;
      padding: 3px;
      z-index: 1000;
    }

    #heat-bar {
      width: 0%;
      height: 100%;
      border-radius: 12px;
      background: #03a1fc; /* Blue at start */
      transition: width 0.1s, background 0.2s;
    }

    /* Power-up indicators */
    #powerups {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .powerup-indicator {
      background: rgba(0, 0, 0, 0.8);
      padding: 10px 15px;
      border-radius: 8px;
      color: white;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 10px;
      animation: pulse 0.5s ease-in-out;
    }

    @keyframes pulse {

      0%,
      100% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.1);
      }
    }

    .powerup-icon {
      font-size: 24px;
    }

    .powerup-timer {
      font-size: 16px;
      font-weight: bold;
    }

    /* Controls hint */
    #controls {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      padding: 15px 30px;
      border-radius: 10px;
      color: white;
      font-size: 14px;
      text-align: center;
      animation: fadeOut 5s forwards;
    }

    @keyframes fadeOut {

      0%,
      80% {
        opacity: 1;
      }

      100% {
        opacity: 0;
      }
    }

    /* Game Over Screen */
    #game-over {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 40px 60px;
      border-radius: 20px;
      text-align: center;
      color: white;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      transition: transform 0.3s ease-out;
      pointer-events: all;
    }

    #game-over.show {
      transform: translate(-50%, -50%) scale(1);
    }

    #game-over h1 {
      font-size: 48px;
      margin-bottom: 20px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    #game-over .stats {
      margin: 20px 0;
      font-size: 18px;
    }

    #game-over .stats div {
      margin: 10px 0;
    }

    #restart-btn,
    #pause-btn {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      color: white;
      border: none;
      padding: 15px 40px;
      font-size: 18px;
      font-weight: bold;
      border-radius: 50px;
      cursor: pointer;
      margin-top: 20px;
      transition: transform 0.2s;
      pointer-events: all;
    }

    #restart-btn:hover,
    #pause-btn:hover {
      transform: scale(1.1);
    }

    #pause-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      padding: 10px 25px;
      font-size: 16px;
      z-index: 1001;
    }

    /* Loading screen */
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 24px;
      text-align: center;
      background: rgba(0, 0, 0, 0.8);
      padding: 30px 50px;
      border-radius: 15px;
    }

    .spinner {
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top: 4px solid white;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }
  </style>
</head>

<body>
  <canvas id="gameCanvas"></canvas>

  <div id="ui">
    <div id="score-panel">
      <div id="score">Score: 0</div>
      <div id="coin-count">Coins: 0</div>
      <div id="distance">Distance: 0m</div>
    </div>

    <div id="powerups"></div>

    <div id="heat-bar-container">
      <div id="heat-bar"></div>
    </div>

    <div id="controls">
      ‚Üê ‚Üí Arrow Keys: Switch Lanes | ‚Üë Space: Jump | ‚Üì Shift: Slide
    </div>

    <button id="pause-btn">Pause</button>

    <div id="game-over">
      <h1>Game Over!</h1>
      <div class="stats">
        <div>Final Score: <span id="final-score">0</span></div>
        <div>Coins Collected: <span id="final-coins">0</span></div>
        <div>Distance: <span id="final-distance">0</span>m</div>
      </div>
      <button id="restart-btn">Restart</button>
    </div>

    <div id="loading">
      <div>Loading Game...</div>
      <div class="spinner"></div>
    </div>
  </div>

  <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // ==================== GAME CONFIGURATION ====================
    const CONFIG = {
      lanes: [-2.5, 0, 2.5], // X positions for left, center, right lanes
      playerSpeed: 0.15, // Forward movement speed
      speedIncrease: 0.00005, // Gradual speed increase
      maxSpeed: 0.35,
      laneChangeSpeed: 0.15, // Smoothness of lane transitions
      jumpForce: 0.25,
      gravity: -0.015,
      slideHeight: 0.5,
      normalHeight: 1.8,
      segmentLength: 30,
      segmentPoolSize: 5,
      obstacleSpawnChance: 0.6,
      coinSpawnChance: 0.8,
      powerUpSpawnChance: 0.05,
      coinValue: 10,
      distanceMultiplier: 1,
      powerUpDuration: 5000, // 5 seconds
      redObstacleThreshold: 100, // Red obstacles appear after 100m
    };

    // ==================== GAME STATE ====================
    const gameState = {
      score: 0,
      coins: 0,
      distance: 0,
      speed: CONFIG.playerSpeed,
      isPlaying: false,
      isPaused: false,
      isGameOver: false,
      isFalling: false,
      currentLane: 1, // 0=left, 1=center, 2=right
      isJumping: false,
      isSliding: false,
      activeShield: false,
      activeMagnet: false,
      activeSpeedBoost: false,
      activeDoubleScore: false,
      powerUpTimers: {},
      heat: 0, // Heat bar (0-100)
      heatIncreaseRate: 0.1, // Heat increase per frame
    };

    // ==================== SCENE SETUP ====================
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x667eea, 10, 80);

    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 4, 8);
    camera.lookAt(0, 2, 0);

    const renderer = new THREE.WebGLRenderer({
      canvas: document.getElementById('gameCanvas'),
      antialias: true,
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // ==================== LIGHTING ====================
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 10, 5);
    dirLight.castShadow = true;
    dirLight.shadow.camera.left = -20;
    dirLight.shadow.camera.right = 20;
    dirLight.shadow.camera.top = 20;
    dirLight.shadow.camera.bottom = -20;
    dirLight.shadow.mapSize.width = 2048;
    dirLight.shadow.mapSize.height = 2048;
    scene.add(dirLight);

    // ==================== PLAYER CLASS ====================
    class Player {
      constructor() {
        this.model = null;
        this.mixer = null;
        this.animations = {};
        this.currentAnimation = null;
        this.position = new THREE.Vector3(0, 0, 0);
        this.velocity = new THREE.Vector3(0, 0, 0);
        this.targetLane = 1;
        this.boundingBox = new THREE.Box3();
        this.width = 0.8;
        this.height = CONFIG.normalHeight;
        this.depth = 0.8;
      }

      load(onComplete) {
        const loader = new GLTFLoader();
        loader.load(
          './ajboy.glb',
          (gltf) => {
            this.model = gltf.scene;
            this.model.scale.set(1, 1, 1);
            this.model.rotation.y = Math.PI;
            this.model.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });

            // Setup animations
            this.mixer = new THREE.AnimationMixer(this.model);
            const clips = gltf.animations;

            // Debug: Log all animation names from the file
            console.log('All animation clips found:', clips.map(c => c.name));
            
            // Find animations by name (check exact names first, then patterns)
            clips.forEach((clip) => {
              const name = clip.name.toLowerCase();
              const exactName = clip.name; // Keep original case for exact matching
              
              // Check for exact matches first (most reliable)
              if (exactName === 'fall-backward' || name === 'fall-backward') {
                this.animations.fallBackward = this.mixer.clipAction(clip);
                this.animations.fallBackward.setLoop(THREE.LoopOnce);
                this.animations.fallBackward.clampWhenFinished = true;
                console.log('‚úì Found fall-backward animation:', exactName);
              } else if (exactName === 'fall-forward' || name === 'fall-forward') {
                this.animations.fallForward = this.mixer.clipAction(clip);
                this.animations.fallForward.setLoop(THREE.LoopOnce);
                this.animations.fallForward.clampWhenFinished = true;
                console.log('‚úì Found fall-forward animation:', exactName);
              } else if (exactName === 'jump' || name === 'jump') {
                this.animations.jump = this.mixer.clipAction(clip);
                this.animations.jump.setLoop(THREE.LoopOnce);
                this.animations.jump.clampWhenFinished = true;
                console.log('‚úì Found jump animation:', exactName);
              } else if (exactName === 'run' || name === 'run') {
                this.animations.run = this.mixer.clipAction(clip);
                console.log('‚úì Found run animation:', exactName);
              } else if (exactName === 'idle' || name === 'idle') {
                this.animations.idle = this.mixer.clipAction(clip);
                console.log('‚úì Found idle animation:', exactName);
              } else if (name.includes('run') && !this.animations.run) {
                this.animations.run = this.mixer.clipAction(clip);
                console.log('‚úì Found run animation (pattern match):', exactName);
              } else if (name.includes('jump') && !this.animations.jump) {
                this.animations.jump = this.mixer.clipAction(clip);
                this.animations.jump.setLoop(THREE.LoopOnce);
                this.animations.jump.clampWhenFinished = true;
                console.log('‚úì Found jump animation (pattern match):', exactName);
              } else if (name.includes('slide') || name.includes('crouch')) {
                this.animations.slide = this.mixer.clipAction(clip);
                this.animations.slide.setLoop(THREE.LoopOnce);
                this.animations.slide.clampWhenFinished = true;
                console.log('‚úì Found slide animation:', exactName);
              } else if ((name.includes('fall-backward') || name.includes('fallbackward') || (name.includes('fall') && name.includes('back'))) && !this.animations.fallBackward) {
                this.animations.fallBackward = this.mixer.clipAction(clip);
                this.animations.fallBackward.setLoop(THREE.LoopOnce);
                this.animations.fallBackward.clampWhenFinished = true;
                console.log('‚úì Found fall-backward animation (pattern match):', exactName);
              } else if ((name.includes('fall-forward') || name.includes('fallforward') || (name.includes('fall') && name.includes('forward'))) && !this.animations.fallForward) {
                this.animations.fallForward = this.mixer.clipAction(clip);
                this.animations.fallForward.setLoop(THREE.LoopOnce);
                this.animations.fallForward.clampWhenFinished = true;
                console.log('‚úì Found fall-forward animation (pattern match):', exactName);
              } else if (name.includes('fall') && !this.animations.fallBackward && !this.animations.fallForward) {
                // Generic fall animation as fallback
                this.animations.fall = this.mixer.clipAction(clip);
                this.animations.fall.setLoop(THREE.LoopOnce);
                this.animations.fall.clampWhenFinished = true;
                console.log('‚úì Found fall animation (generic):', exactName);
              }
            });

            // Fallback: use first animation as run if not found
            if (!this.animations.run && clips.length > 0) {
              this.animations.run = this.mixer.clipAction(clips[0]);
            }

            // Fallback: use third animation as fall if not found by name
            if (!this.animations.fall && !this.animations.fallBackward && !this.animations.fallForward && clips.length > 2) {
              this.animations.fall = this.mixer.clipAction(clips[2]);
              this.animations.fall.setLoop(THREE.LoopOnce);
              this.animations.fall.clampWhenFinished = true;
            }

            // Debug: Log loaded animations
            console.log('Loaded animations:', Object.keys(this.animations));
            if (this.animations.fallBackward) console.log('‚úì fall-backward animation loaded');
            if (this.animations.jump) console.log('‚úì jump animation loaded');

            // Start with run animation
            if (this.animations.run) {
              this.animations.run.play();
              this.currentAnimation = this.animations.run;
            }

            scene.add(this.model);
            this.updatePosition();
            onComplete();
          },
          undefined,
          (error) => {
            console.error('Error loading player model:', error);
            onComplete();
          }
        );
      }

      playAnimation(name, fadeTime = 0.2) {
        const newAction = this.animations[name];
        if (!newAction) {
          console.warn(`Animation "${name}" not found. Available animations:`, Object.keys(this.animations));
          return;
        }
        
        if (newAction === this.currentAnimation) {
          console.log(`Animation "${name}" is already playing`);
          return;
        }

        console.log(`Playing animation: ${name}`);
        if (this.currentAnimation) {
          this.currentAnimation.fadeOut(fadeTime);
        }

        newAction.reset();
        newAction.fadeIn(fadeTime);
        newAction.play();
        this.currentAnimation = newAction;
      }

      jump() {
        if (gameState.isFalling) {
          console.log('Cannot jump: player is falling');
          return;
        }

        if (!gameState.isJumping && !gameState.isSliding) {
          gameState.isJumping = true;
          this.velocity.y = CONFIG.jumpForce;
          console.log('Jump triggered. Available animations:', Object.keys(this.animations));
          this.playAnimation('jump', 0.1);
        } else {
          console.log('Cannot jump: isJumping=', gameState.isJumping, 'isSliding=', gameState.isSliding);
        }
      }

      slide() {
        if (gameState.isFalling) return;

        if (!gameState.isSliding && !gameState.isJumping) {
          gameState.isSliding = true;
          this.height = CONFIG.slideHeight;
          this.playAnimation('slide', 0.1);
          setTimeout(() => {
            gameState.isSliding = false;
            this.height = CONFIG.normalHeight;
            if (!gameState.isJumping) {
              this.playAnimation('run', 0.2);
            }
          }, 500);
        }
      }

      changeLane(direction) {
        gameState.currentLane += direction;
        gameState.currentLane = Math.max(0, Math.min(2, gameState.currentLane));
        this.targetLane = gameState.currentLane;
      }

      update(deltaTime) {
        if (!this.model) return;

        // Update animation mixer
        if (this.mixer) {
          this.mixer.update(deltaTime);
        }

        // Lane switching (smooth lerp)
        const targetX = CONFIG.lanes[this.targetLane];
        this.position.x += (targetX - this.position.x) * CONFIG.laneChangeSpeed;

        // Jumping physics
        if (gameState.isJumping) {
          this.velocity.y += CONFIG.gravity;
          this.position.y += this.velocity.y;

          if (this.position.y <= 0) {
            this.position.y = 0;
            this.velocity.y = 0;
            gameState.isJumping = false;
            if (!gameState.isSliding) {
              this.playAnimation('run', 0.2);
            }
          }
        }

        this.updatePosition();
        this.updateBoundingBox();
      }

      updatePosition() {
        if (this.model) {
          this.model.position.copy(this.position);
        }
      }

      updateBoundingBox() {
        const halfWidth = this.width / 2;
        const halfDepth = this.depth / 2;
        this.boundingBox.min.set(
          this.position.x - halfWidth,
          this.position.y,
          this.position.z - halfDepth
        );
        this.boundingBox.max.set(
          this.position.x + halfWidth,
          this.position.y + this.height,
          this.position.z + halfDepth
        );
      }

      hit(obstacle) {
        if (gameState.activeShield) {
          deactivatePowerUp('shield');
          return false;
        }

        if (gameState.isFalling) return false;

        gameState.isFalling = true;

        // Check if obstacle is red
        const isRedObstacle = obstacle && obstacle.isRed === true;
        console.log('Player hit obstacle. Is red?', isRedObstacle);
        console.log('Available animations:', Object.keys(this.animations));

        if (isRedObstacle && this.animations.fallBackward) {
          // Play fall-backward animation for red obstacles
          console.log('Playing fall-backward animation for red obstacle');
          this.playAnimation('fallBackward', 0.1);
        } else if (isRedObstacle && !this.animations.fallBackward) {
          console.warn('Red obstacle hit but fallBackward animation not found!');
          if (this.animations.fall) {
            this.playAnimation('fall', 0.1);
          }
        } else if (this.animations.fall) {
          // Fallback to generic fall animation for non-red obstacles
          console.log('Playing fall animation for non-red obstacle');
          this.playAnimation('fall', 0.1);
        } else {
          console.warn('No fall animation found!');
        }

        return true;
      }
    }

    // ==================== OBSTACLE CLASS ====================
    class Obstacle {
      constructor(lane, zPosition, type = 'static', forceRed = false) {
        this.lane = lane;
        this.type = type; // 'static' or 'moving'
        this.boundingBox = new THREE.Box3();

        // Determine color based on distance or force red
        this.isRed = forceRed || gameState.distance >= CONFIG.redObstacleThreshold;
        const obstacleColor = this.isRed ? 0xff0000 : 0x8b0000;

        // Create visual mesh - shorter obstacles that require jumping
        const geometry = new THREE.BoxGeometry(1.2, 0.8, 1.2);
        const material = new THREE.MeshStandardMaterial({
          color: obstacleColor,
          metalness: 0.3,
          roughness: 0.7
        });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.set(CONFIG.lanes[lane], 0.4, zPosition); // Lower position to sit on ground
        this.mesh.castShadow = true;
        this.mesh.receiveShadow = true;

        // Moving obstacles have velocity
        this.velocity = type === 'moving' ? 0.1 : 0;

        scene.add(this.mesh);
        this.updateBoundingBox();
      }

      update() {
        if (this.type === 'moving') {
          this.mesh.position.z += this.velocity;
        }
        this.updateBoundingBox();
      }

      updateBoundingBox() {
        this.boundingBox.setFromObject(this.mesh);
      }

      remove() {
        scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
      }
    }

    // ==================== COIN CLASS ====================
    class Coin {
      constructor(x, y, z, useSoapModel = false) {
        this.collected = false;
        this.boundingBox = new THREE.Box3();
        this.useSoapModel = useSoapModel;
        this.modelLoaded = false;
        this.baseY = 0.6; // Base height above ground
        this.floatTime = Math.random() * Math.PI * 2; // Random starting phase

        if (useSoapModel && models.soap) {
          this.mesh = models.soap.clone();
          this.mesh.scale.set(0.3, 0.3, 0.3);
          this.modelLoaded = true;
        } else if (!useSoapModel && models.coin) {
          this.mesh = models.coin.clone();
          this.mesh.scale.set(5, 5, 5);
          this.modelLoaded = true;
        } else {
          // Fallback to simple geometry
          const geometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16);
          const material = new THREE.MeshStandardMaterial({
            color: 0xffd700,
            metalness: 0.8,
            roughness: 0.2,
            emissive: 0xffd700,
            emissiveIntensity: 0.3
          });
          this.mesh = new THREE.Mesh(geometry, material);
          this.mesh.rotation.x = Math.PI / 2;
        }

        this.mesh.position.set(x, this.baseY, z);
        this.mesh.castShadow = true;
        this.rotationSpeed = 0.05;

        scene.add(this.mesh);
        this.updateBoundingBox();
      }

      update() {
        // Float animation
        this.floatTime += 0.05;
        this.mesh.position.y = this.baseY + Math.sin(this.floatTime) * 0.15; // Float 0.15 units up and down
        
        // Rotate
        this.mesh.rotation.y += this.rotationSpeed;
        this.updateBoundingBox();
      }

      updateBoundingBox() {
        this.boundingBox.setFromObject(this.mesh);
      }

      collect() {
        this.collected = true;
        scene.remove(this.mesh);
        if (this.mesh.geometry) this.mesh.geometry.dispose();
        if (this.mesh.material) this.mesh.material.dispose();
      }
    }

    // ==================== POWER-UP CLASS ====================
    class PowerUp {
      constructor(x, z, type) {
        this.type = type; // 'shield', 'magnet', 'speedboost', 'doublescore'
        this.collected = false;
        this.boundingBox = new THREE.Box3();

        const colors = {
          shield: 0x00ffff,
          magnet: 0xff00ff,
          speedboost: 0xff8800,
          doublescore: 0x00ff00
        };

        const geometry = new THREE.SphereGeometry(0.5, 16, 16);
        const material = new THREE.MeshStandardMaterial({
          color: colors[type],
          metalness: 0.5,
          roughness: 0.3,
          emissive: colors[type],
          emissiveIntensity: 0.5
        });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.set(x, 1, z);
        this.mesh.castShadow = true;

        // Add glow light
        this.light = new THREE.PointLight(colors[type], 1, 5);
        this.light.position.copy(this.mesh.position);
        scene.add(this.light);

        this.floatTime = 0;
        scene.add(this.mesh);
        this.updateBoundingBox();
      }

      update(deltaTime) {
        this.floatTime += deltaTime * 2;
        this.mesh.position.y = 1 + Math.sin(this.floatTime) * 0.3;
        this.mesh.rotation.y += 0.05;
        this.light.position.copy(this.mesh.position);
        this.updateBoundingBox();
      }

      updateBoundingBox() {
        this.boundingBox.setFromObject(this.mesh);
      }

      collect() {
        this.collected = true;
        scene.remove(this.mesh);
        scene.remove(this.light);
        if (this.mesh.geometry) this.mesh.geometry.dispose();
        if (this.mesh.material) this.mesh.material.dispose();
      }
    }

    // ==================== TRACK SEGMENT CLASS ====================
    class TrackSegment {
      constructor(zPosition) {
        this.zPosition = zPosition;
        this.obstacles = [];
        this.coins = [];
        this.powerUps = [];

        // Create ground mesh
        const geometry = new THREE.BoxGeometry(10, 0.5, CONFIG.segmentLength);
        const material = new THREE.MeshStandardMaterial({
          color: 0x444444,
          roughness: 0.8
        });
        this.ground = new THREE.Mesh(geometry, material);
        this.ground.position.set(0, -0.25, zPosition);
        this.ground.receiveShadow = true;
        scene.add(this.ground);

        // Add lane markers
        this.createLaneMarkers();

        // Populate with obstacles and collectibles
        this.populate();
      }

      createLaneMarkers() {
        const markerGeometry = new THREE.BoxGeometry(0.2, 0.1, 2);
        const markerMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00 });

        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 5; j++) {
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            const laneX = i === 1 ? -1.2 : 1.2; // Between lanes
            if (i === 0) continue; // Skip first iteration
            marker.position.set(
              laneX,
              0,
              this.zPosition - CONFIG.segmentLength / 2 + j * 6
            );
            scene.add(marker);
          }
        }
      }

      populate() {
        const numRows = 5;
        const rowSpacing = CONFIG.segmentLength / numRows;

        for (let i = 0; i < numRows; i++) {
          const z = this.zPosition - CONFIG.segmentLength / 2 + i * rowSpacing + rowSpacing / 2;

          // Spawn obstacles
          if (Math.random() < CONFIG.obstacleSpawnChance) {
            const lane = Math.floor(Math.random() * 3);
            const isMoving = Math.random() < 0.2;
            const forceRed = gameState.distance >= CONFIG.redObstacleThreshold;
            const obstacle = new Obstacle(lane, z, isMoving ? 'moving' : 'static', forceRed);
            this.obstacles.push(obstacle);
          }

          // Spawn coins (in patterns)
          if (Math.random() < CONFIG.coinSpawnChance) {
            const pattern = Math.floor(Math.random() * 3);
            const coinHeight = 0.6; // All coins at ground level + slight height

            if (pattern === 0) {
              // Single lane line
              const lane = Math.floor(Math.random() * 3);
              for (let j = 0; j < 5; j++) {
                const coin = new Coin(CONFIG.lanes[lane], coinHeight, z + j * 0.5);
                this.coins.push(coin);
              }
            } else if (pattern === 1) {
              // All lanes
              for (let lane = 0; lane < 3; lane++) {
                const coin = new Coin(CONFIG.lanes[lane], coinHeight, z);
                this.coins.push(coin);
              }
            } else {
              // Horizontal zigzag pattern (all on ground)
              for (let j = 0; j < 5; j++) {
                const xOffset = (j % 2 === 0) ? -1 : 1;
                const coin = new Coin(xOffset, coinHeight, z + j * 0.8);
                this.coins.push(coin);
              }
            }
          }

          // Spawn power-ups (rare)
          if (Math.random() < CONFIG.powerUpSpawnChance) {
            const lane = Math.floor(Math.random() * 3);
            const types = ['shield', 'magnet', 'speedboost', 'doublescore'];
            const type = types[Math.floor(Math.random() * types.length)];
            const powerUp = new PowerUp(CONFIG.lanes[lane], z, type);
            this.powerUps.push(powerUp);
          }
        }
      }

      update(deltaTime) {
        this.obstacles.forEach(obs => obs.update());
        this.coins.forEach(coin => coin.update());
        this.powerUps.forEach(pu => pu.update(deltaTime));
      }

      reset(newZ) {
        this.zPosition = newZ;
        this.ground.position.z = newZ;

        // Clean up old objects
        this.obstacles.forEach(obs => obs.remove());
        this.coins.forEach(coin => { if (!coin.collected) coin.collect(); });
        this.powerUps.forEach(pu => { if (!pu.collected) pu.collect(); });

        this.obstacles = [];
        this.coins = [];
        this.powerUps = [];

        this.populate();
      }

      remove() {
        scene.remove(this.ground);
        this.ground.geometry.dispose();
        this.ground.material.dispose();
        this.obstacles.forEach(obs => obs.remove());
        this.coins.forEach(coin => { if (!coin.collected) coin.collect(); });
        this.powerUps.forEach(pu => { if (!pu.collected) pu.collect(); });
      }
    }

    // ==================== WORLD MANAGER ====================
    class WorldManager {
      constructor() {
        this.segments = [];
        this.initSegments();
      }

      initSegments() {
        for (let i = 0; i < CONFIG.segmentPoolSize; i++) {
          const segment = new TrackSegment(-CONFIG.segmentLength * i);
          this.segments.push(segment);
        }
      }

      update(deltaTime, playerZ) {
        this.segments.forEach(segment => segment.update(deltaTime));

        // Check if we need to recycle segments
        const lastSegment = this.segments[this.segments.length - 1];
        if (playerZ < lastSegment.zPosition + CONFIG.segmentLength) {
          const firstSegment = this.segments.shift();
          const newZ = lastSegment.zPosition - CONFIG.segmentLength;
          firstSegment.reset(newZ);
          this.segments.push(firstSegment);
        }
      }

      getAllObstacles() {
        return this.segments.flatMap(s => s.obstacles);
      }

      getAllCoins() {
        return this.segments.flatMap(s => s.coins);
      }

      getAllPowerUps() {
        return this.segments.flatMap(s => s.powerUps);
      }
    }

    // ==================== COLLISION DETECTION ====================
    function checkCollision(box1, box2) {
      return box1.intersectsBox(box2);
    }

    // ==================== POWER-UP SYSTEM ====================
    function activatePowerUp(type) {
      const icons = {
        shield: 'üõ°Ô∏è',
        magnet: 'üß≤',
        speedboost: '‚ö°',
        doublescore: 'üíé'
      };

      if (type === 'shield') {
        gameState.activeShield = true;
      } else if (type === 'magnet') {
        gameState.activeMagnet = true;
      } else if (type === 'speedboost') {
        gameState.activeSpeedBoost = true;
      } else if (type === 'doublescore') {
        gameState.activeDoubleScore = true;
      }

      // Add UI indicator
      const container = document.getElementById('powerups');
      const indicator = document.createElement('div');
      indicator.className = 'powerup-indicator';
      indicator.id = `powerup-${type}`;
      indicator.innerHTML = `
        <span class="powerup-icon">${icons[type]}</span>
        <span class="powerup-timer" id="timer-${type}">5.0s</span>
      `;
      container.appendChild(indicator);

      // Set timer
      const startTime = Date.now();
      gameState.powerUpTimers[type] = setInterval(() => {
        const elapsed = Date.now() - startTime;
        const remaining = Math.max(0, (CONFIG.powerUpDuration - elapsed) / 1000);
        const timerEl = document.getElementById(`timer-${type}`);
        if (timerEl) {
          timerEl.textContent = remaining.toFixed(1) + 's';
        }
      }, 100);

      // Deactivate after duration
      setTimeout(() => deactivatePowerUp(type), CONFIG.powerUpDuration);
    }

    function deactivatePowerUp(type) {
      if (type === 'shield') {
        gameState.activeShield = false;
      } else if (type === 'magnet') {
        gameState.activeMagnet = false;
      } else if (type === 'speedboost') {
        gameState.activeSpeedBoost = false;
      } else if (type === 'doublescore') {
        gameState.activeDoubleScore = false;
      }

      // Remove UI indicator
      const indicator = document.getElementById(`powerup-${type}`);
      if (indicator) indicator.remove();

      // Clear timer
      if (gameState.powerUpTimers[type]) {
        clearInterval(gameState.powerUpTimers[type]);
        delete gameState.powerUpTimers[type];
      }
    }

    // ==================== MODEL LOADING ====================
    const models = {
      soap: null,
      coin: null
    };

    function loadModels(callback) {
      const loader = new GLTFLoader();
      let loaded = 0;
      const total = 2;

      const checkComplete = () => {
        loaded++;
        if (loaded === total) callback();
      };

      loader.load('./soap.glb',
        (gltf) => {
          models.soap = gltf.scene;
          models.soap.scale.set(0.2, 0.2, 0.2);
          checkComplete();
        },
        undefined,
        () => checkComplete() // Error fallback
      );

      loader.load('./coin.glb',
        (gltf) => {
          models.coin = gltf.scene;
          models.coin.scale.set(0.2, 0.2, 0.2);
          models.coin.traverse((child) => {
            if (child.isMesh && child.material) {
              child.material.emissive = new THREE.Color(0xffd700);
              child.material.emissiveIntensity = 0.5;
            }
          });
          checkComplete();
        },
        undefined,
        () => checkComplete() // Error fallback
      );
    }

    // ==================== UI UPDATES ====================
    function updateUI() {
      document.getElementById('score').textContent = `Score: ${gameState.score}`;
      document.getElementById('coin-count').textContent = `Coins: ${gameState.coins}`;
      document.getElementById('distance').textContent = `Distance: ${Math.floor(gameState.distance)}m`;
      
      // Update heat bar
      const heatBar = document.getElementById('heat-bar');
      heatBar.style.width = gameState.heat + '%';
      
      // Update heat bar color based on level
      if (gameState.heat >= 100) {
        heatBar.style.background = '#fc2803'; // Red at 100%
      } else if (gameState.heat >= 50) {
        heatBar.style.background = '#fce803'; // Yellow at 50%+
      } else {
        heatBar.style.background = '#03a1fc'; // Blue below 50%
      }
    }

    function showGameOver() {
      gameState.isGameOver = true;
      gameState.isPlaying = false;

      document.getElementById('final-score').textContent = gameState.score;
      document.getElementById('final-coins').textContent = gameState.coins;
      document.getElementById('final-distance').textContent = Math.floor(gameState.distance);

      setTimeout(() => {
        document.getElementById('game-over').classList.add('show');
      }, 1000);
    }

    // ==================== CAMERA SYSTEM ====================
    function updateCamera(player) {
      if (!player.model) return;

      const targetX = player.position.x;
      const targetY = player.position.y + 4;
      const targetZ = player.position.z + 8;

      camera.position.x += (targetX - camera.position.x) * 0.1;
      camera.position.y += (targetY - camera.position.y) * 0.1;
      camera.position.z += (targetZ - camera.position.z) * 0.1;

      // Subtle sway based on lane
      const sway = Math.sin(Date.now() * 0.001) * 0.1;
      camera.position.x += sway;

      camera.lookAt(player.position.x, player.position.y + 1, player.position.z - 5);
    }

    // ==================== INPUT HANDLING ====================
    const keys = {};

    window.addEventListener('keydown', (e) => {
      keys[e.code] = true;

      if (!gameState.isPlaying || gameState.isPaused) return;

      if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
        player.changeLane(-1);
      } else if (e.code === 'ArrowRight' || e.code === 'KeyD') {
        player.changeLane(1);
      } else if (e.code === 'ArrowUp' || e.code === 'Space') {
        e.preventDefault();
        player.jump();
      } else if (e.code === 'ArrowDown' || e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
        e.preventDefault();
        player.slide();
      } else if (e.code === 'Escape') {
        togglePause();
      }
    });

    window.addEventListener('keyup', (e) => {
      keys[e.code] = false;
    });

    // ==================== GAME LOOP ====================
    let lastTime = 0;
    const player = new Player();
    let world;

    function gameLoop(currentTime) {
      requestAnimationFrame(gameLoop);

      const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
      lastTime = currentTime;

      if (!gameState.isPlaying || gameState.isPaused) {
        if (player.mixer) {
          player.mixer.update(deltaTime);
        }
        renderer.render(scene, camera);
        return;
      }

      // Update player
      player.update(deltaTime);

      // Update world (move track segments)
      player.position.z -= gameState.speed;
      gameState.distance += gameState.speed * 3; // Reduced from 10 to 3 for slower distance counting

      // Increase speed gradually
      if (gameState.speed < CONFIG.maxSpeed) {
        gameState.speed += CONFIG.speedIncrease;
      }

      // Apply speed boost
      const speedMultiplier = gameState.activeSpeedBoost ? 1.5 : 1;

      // Update world
      world.update(deltaTime, player.position.z);

      // Check collisions with obstacles
      const obstacles = world.getAllObstacles();
      for (const obstacle of obstacles) {
        if (checkCollision(player.boundingBox, obstacle.boundingBox)) {
          if (player.hit(obstacle)) {
            // Stop movement but allow animation
            gameState.isPlaying = false;

            setTimeout(() => {
              showGameOver();
            }, 1500); // match fall animation duration

            return;
          }
        }
      }

      // Update heat bar (only when playing and not falling)
      if (gameState.isPlaying && !gameState.isPaused && !gameState.isFalling && gameState.heat < 100) {
        gameState.heat += gameState.heatIncreaseRate;
        if (gameState.heat > 100) gameState.heat = 100;
      }

      // Check if heat reached 100% - trigger fall-forward animation
      if (gameState.heat >= 100 && !gameState.isFalling && gameState.isPlaying) {
        gameState.isFalling = true;
        gameState.isPlaying = false;
        
        if (player.animations.fallForward) {
          player.playAnimation('fallForward', 0.1);
        } else if (player.animations.fall) {
          player.playAnimation('fall', 0.1);
        }

        setTimeout(() => {
          showGameOver();
        }, 1500); // match fall animation duration
        
        return; // Stop game loop
      }

      // Check coin collection
      const coins = world.getAllCoins();
      for (const coin of coins) {
        if (coin.collected) continue;

        // Magnet effect
        if (gameState.activeMagnet) {
          const dx = player.position.x - coin.mesh.position.x;
          const dz = player.position.z - coin.mesh.position.z;
          const distance = Math.sqrt(dx * dx + dz * dz);

          if (distance < 5) {
            coin.mesh.position.x += dx * 0.1;
            coin.mesh.position.z += dz * 0.1;
          }
        }

        if (checkCollision(player.boundingBox, coin.boundingBox)) {
          coin.collect();
          gameState.coins++;
          const points = CONFIG.coinValue * (gameState.activeDoubleScore ? 2 : 1);
          gameState.score += points;
        }
      }

      // Check power-up collection
      const powerUps = world.getAllPowerUps();
      for (const powerUp of powerUps) {
        if (powerUp.collected) continue;

        if (checkCollision(player.boundingBox, powerUp.boundingBox)) {
          powerUp.collect();
          activatePowerUp(powerUp.type);
        }
      }

      // Update score from distance
      gameState.score += CONFIG.distanceMultiplier * (gameState.activeDoubleScore ? 2 : 1);

      // Update camera
      updateCamera(player);

      // Update UI
      updateUI();

      // Render
      renderer.render(scene, camera);
    }

    // ==================== GAME CONTROLS ====================
    function togglePause() {
      gameState.isPaused = !gameState.isPaused;
      document.getElementById('pause-btn').textContent = gameState.isPaused ? 'Resume' : 'Pause';
    }

    function restartGame() {
      location.reload();
    }

    document.getElementById('pause-btn').addEventListener('click', togglePause);
    document.getElementById('restart-btn').addEventListener('click', restartGame);

    // ==================== INITIALIZATION ====================
    function startGame() {
      document.getElementById('loading').style.display = 'none';
      gameState.isPlaying = true;
      gameState.isPaused = false;
      lastTime = performance.now();
      gameLoop(lastTime);
    }

    // Load all assets
    loadModels(() => {
      player.load(() => {
        world = new WorldManager();
        startGame();
      });
    });

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>

</html>